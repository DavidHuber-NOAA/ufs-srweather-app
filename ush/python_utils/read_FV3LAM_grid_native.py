# **********************************************************************
#
# File name: read_FV3LAM_grid_native.ncl
# Author: Gerard Ketefian
#
# Description:
# ^^^^^^^^^^^
# This function returns the file names, dimensions, cell center coordinates,
# and cell vertex coordinates of the grids associated with the specified
# FV3 cubed-sphere tiles (tile_inds).  If get_tile_bdies is set to True,
# it also returns the coordinates of those grid cell vertices that lie on
# the boundary of each specified tile.
#
# The input arguments to this function are as follows:
#
# expt_dir:
# This is the experiment directory created by the FV3SAR workflow generation
# script.  The grid specification files corresponding to the cubed-sphere
# tiles are within subdirectories under this directory.
#
# gtype:
# This is a string containing the type of the FV3 cubed-sphere grid being
# read in.  For files generated by the FV3SAR workflow, this will be equal
# to "regional".
#
# cres:
# This is the C-resolution of the global cubed-sphere grid that serves
# as the "parent" of the regional grid.  It consists of the character
# "C" followed by an interger that is equal to the number of grid cells
# in each of the two horizontal directions (say x and y) on each of the
# six tiles of the parent global grid.  Note that this number is in general
# not equal to the number of grid cells on the regional grid (i.e. the
# one on tile 7) because the latter is given by the former multiplied by
# a refinement factor (an integer) that is normally greater than 1.
#
# tile_inds:
# The indices of the tiles (associated with ither the parent global grid
# or the regional grid) to consider in this function.
#
# get_tile_bdies:
# A logical variable that specifies whether arrays containing the coordinates
# of grid cell vertices that lie on the boundary of each tile specified
# in tile_inds are to be extracted and returned.
#
# nhalo_T7:
# The width of the halo (in units of grid cells) included in the grid
# specification file for the regional grid (tile 7).  If tile_inds includes
# tile 7, then this is used to form the name of the grid file for that
# tile.  Also, if tile_inds includes tile 7 and if remove_rgnl_halo is
# set to True, then a halo of width nhalo_T7 is removed from any arrays
# read in from the tile 7 grid file.  This is not used if tile_inds does
# not include tile 7.
#
# remove_rgnl_halo:
# Flag indicating whether to remove a halo of width nhalo_T7 from any
# arrays read in from the tile 7 grid file.  This is not used if tile_inds
# does not include tile 7.
#
# **********************************************************************

import os
from netCDF4 import Dataset
import numpy as np
from .adjust_longitude_range import adjust_longitude_range
from .get_rect_grid_bdy import get_rect_grid_bdy
from .get_rect_grid_corners import get_rect_grid_corners

def read_FV3LAM_grid_native( expt_dir, gtype, cres, tile_inds, get_tile_bdies,
      nhalo_T7, remove_rgnl_halo):

# **********************************************************************
# Define the string separator_line that serves
# as a separator line between different sections of printout.
# **********************************************************************
  separator_line = "="*72

#
# **********************************************************************
#
# Loop through the tiles and set the following arrays:
#
# grid_fn_all_tiles:
# Full path to the grid file corresponding to each tile.  Note that the
# grid file contains information (coordinates, etc) on the supergrid of
# a given tile, where the supergrid is a grid having twice the resolution
# of the actual (i.e. computational) grid.
#
# remove_halo_all_tiles:
# Logical array that specifies whether the halo cells around a given tile
# should be removed before plotting or other processing.
#
# nhSG_all_tiles:
# Halo width on the supergrid of each tile, in units of supergrid cells.
# Normally, only tile 7 of a regional or nexted grid has a halo, so this
# will be zero for tiles 1 through 6.
#
# nxhSG_all_tiles, nyhSG_all_tiles:
# Number of cells, including the halo, in the x and y directions,
# respectively, on the supergrid of each tile.
#
# nxSG_all_tiles, nySG_all_tiles:
# Number of cells, excluding the halo, in the x and y directions,
# respectively, on the supergrid of each tile.
#
# nh_all_tiles:
# Halo width on the computational grid of each tile, in units of grid
# cells.  Normally, only tile 7 of a regional or nexted grid has a halo,
# so this will be zero for tiles 1 through 6.
#
# nxh_all_tiles, nyh_all_tiles:
# Number of cells, including the halo, in the x and y directions,
# respectively, on the computational grid of each tile.
#
# nx_all_tiles, ny_all_tiles:
# Number of cells, excluding the halo, in the x and y directions,
# respectively, on the computational grid of each tile.
#
# coord_data_type_all_tiles:
# The data type of the coordinate arrays in the grid file corresponding
# to each tile.
#
# **********************************************************************
#

  num_tiles_to_plot = len(tile_inds)

  print("")
  print("" + separator_line)
  print("Setting grid file name and dimensions of each specified tile ...")

  grid_fn_all_tiles = []
  remove_halo_all_tiles = []
  nhSG_all_tiles = np.array([], dtype = "int")
  nh_all_tiles = np.array([], dtype = "int")
  nxhSG_all_tiles = np.array([], dtype = "int")
  nyhSG_all_tiles = np.array([], dtype = "int")
  nxSG_all_tiles = np.array([], dtype = "int")
  nySG_all_tiles = np.array([], dtype = "int")
  nxh_all_tiles = np.array([], dtype = "int")
  nyh_all_tiles = np.array([], dtype = "int")
  nx_all_tiles = np.array([], dtype="int")
  ny_all_tiles = np.array([], dtype="int")
  lon_cntrs_all_tiles_unstruc = np.array([],dtype="double")
  lat_cntrs_all_tiles_unstruc = np.array([],dtype="double")
  lon_halo_cntrs_all_tiles_unstruc = np.array([],dtype="double")
  lat_halo_cntrs_all_tiles_unstruc = np.array([],dtype="double")
  lon_bdy_all_tiles = np.array([],dtype="double")
  lat_bdy_all_tiles = np.array([],dtype="double")
  lon_halo_bdy_all_tiles = np.array([],dtype="double")
  lat_halo_bdy_all_tiles = np.array([],dtype="double")
  lon_tile_cntr_all_tiles = np.array([],dtype="double")
  lat_tile_cntr_all_tiles = np.array([],dtype="double")
  lon_tile_corners_face_midpts_all_tiles = np.zeros(
        [num_tiles_to_plot, 8], dtype = "double") - 999.0
  lat_tile_corners_face_midpts_all_tiles = np.zeros(
        [num_tiles_to_plot, 8], dtype = "double") - 999.0

  for nn in range(num_tiles_to_plot):

    n_tile = tile_inds[nn]

#
# **********************************************************************
#
# Set the file name (including path) for the current tile.  Then save the
# result in the grid_fn_all_tiles array for later use.
#
# **********************************************************************
#
# Maybe read in the new parameter DOT_OR_USCORE from the var_defns.sh file.
    grid_fn = f"{cres}_grid.tile{n_tile}"
    if (gtype == "regional") and (n_tile == 7):
      grid_fn = f"{grid_fn}.halo{nhalo_T7}.nc"
    else:
      grid_fn = f"{grid_fn}.nc"

    grid_fn = os.path.join(expt_dir, grid_fn)

    grid_fn_all_tiles = np.append(grid_fn_all_tiles,grid_fn)
    print(f'  grid_fn_all_tiles({nn}) = {grid_fn_all_tiles[nn]}"')
#
# **********************************************************************
#
# Open the NetCDF file containing the grid specification for the current
# tile.
#
# **********************************************************************
#
    fp = Dataset(grid_fn_all_tiles[nn])
#
# **********************************************************************
#
# Set the halo width (in units of cells).  Note that this is zero unless
# we're on a regional or nested grid and and the current tile is tile 7
# (the regional or nested domain/grid).  Also, set the logical variable
# that determines whether the halo should be removed from the current
# tile before any processing is performed.  This is set to True only if
# we're on tile 7 of a regional or nested grid and remove_rgnl_halo is
# set to True.
#
# **********************************************************************
#
    nhSG_all_tiles = np.append(nhSG_all_tiles,0)
    remove_halo_all_tiles = np.append(remove_halo_all_tiles,False)

    if (gtype == "regional" or gtype == "nest") and (n_tile == 7):

      nhSG_all_tiles[nn] = 2*nhalo_T7
      if (remove_rgnl_halo):
        remove_halo_all_tiles[nn] = True

    nh_all_tiles = np.append(nh_all_tiles,int(nhSG_all_tiles[nn]/2))
#
# **********************************************************************
#
# Read in the dimensions of the tile's supergrid (which has twice the
# resolution as the tile's grid).  From these, calculate the dimensions
# of the supergrid.
#
# **********************************************************************
#
    tile_SG_dims = fp["area"].shape

    nxhSG_all_tiles = np.append(nxhSG_all_tiles,tile_SG_dims[1])
    nyhSG_all_tiles = np.append(nyhSG_all_tiles,tile_SG_dims[0])
    nxSG_all_tiles = np.append(nxSG_all_tiles,nxhSG_all_tiles[nn] - 2*nhSG_all_tiles[nn])
    nySG_all_tiles = np.append(nySG_all_tiles,nyhSG_all_tiles[nn] - 2*nhSG_all_tiles[nn])

#
# **********************************************************************
#
# Calculate the dimensions of the computational grid.
#
# **********************************************************************
#

    nxh_all_tiles = np.append(nxh_all_tiles,int(nxhSG_all_tiles[nn]/2))
    nyh_all_tiles = np.append(nyh_all_tiles,int(nyhSG_all_tiles[nn]/2))
    nx_all_tiles = np.append(nx_all_tiles,nxh_all_tiles[nn] - 2*nh_all_tiles[nn])
    ny_all_tiles = np.append(ny_all_tiles,nyh_all_tiles[nn] - 2*nh_all_tiles[nn])

  print("")
  print("Done setting grid file name and dimensions of each specified tile.")
  print("" + separator_line)

#
# **********************************************************************
#

  print("")
  print("" + separator_line)
  print("Reading in grid coordinates of each specified tile from file ...")
  print('num tiles: ', num_tiles_to_plot)

  for nn in range(num_tiles_to_plot):

    n_tile = tile_inds[nn]

#
# **********************************************************************
#
# Get grid dimensions of current tile.
#
# **********************************************************************
#

    nhSG = int(nhSG_all_tiles[nn])
    nxhSG = int(nxhSG_all_tiles[nn])
    nyhSG = int(nyhSG_all_tiles[nn])
    nxSG = int(nxSG_all_tiles[nn])
    nySG = int(nySG_all_tiles[nn])

    nh = int(nh_all_tiles[nn])
    nxh = int(nxh_all_tiles[nn])
    nyh = int(nyh_all_tiles[nn])
    nx = int(nx_all_tiles[nn])
    ny = int(ny_all_tiles[nn])

    remove_halo = remove_halo_all_tiles[nn]

#
# **********************************************************************
#
# Open the NetCDF file containing the grid specification for the current
# tile.
#
# **********************************************************************
#
    fp = Dataset(grid_fn_all_tiles[nn])
#
# **********************************************************************
#
# Read in the supergrid coordinates.  The supergrid of a given tile is a
# grid having twice the resolution of the actual (i.e. computational)
# grid of that tile.  It is used to store the coordintes of both the
# centers and the vertices of the cells on the computational grid.
#
# **********************************************************************
#

    lon_verts_SG_crnt_tile = fp["x"]
    lat_verts_SG_crnt_tile = fp["y"]

    lon_verts_SG_crnt_tile = adjust_longitude_range(
          lon_verts_SG_crnt_tile, -180.0, "degs")
#
# **********************************************************************
#
# Get the coordinates of the cell vertices on the current tile from those
# of the supergrid.
#
# **********************************************************************
#
    lon_verts_crnt_tile = lon_verts_SG_crnt_tile[0::2,0::2]
    lat_verts_crnt_tile = lat_verts_SG_crnt_tile[0::2,0::2]
#
# **********************************************************************
#
# Get the coordinates of the cell centers on the current tile from those
# of the supergrid.
#
# **********************************************************************
#
    lon_cntrs_crnt_tile = lon_verts_SG_crnt_tile[1::2,1::2]
    lat_cntrs_crnt_tile = lat_verts_SG_crnt_tile[1::2,1::2]
#
# **********************************************************************
#
# Set arrays containing the coordinates of just the halo cells (with all
# internal cells' coordinates set to the approprite type of fill value).
# This approach allows us to more conveniently plot just the halo cells
# using the same plotting routines as for the internal cells.
#
# **********************************************************************
#
    lon_halo_cntrs_crnt_tile = lon_cntrs_crnt_tile
    lon_halo_cntrs_crnt_tile[nh:nyh-nh,nh:nxh-nh+1] = -999.0
    lat_halo_cntrs_crnt_tile = lat_cntrs_crnt_tile
    lat_halo_cntrs_crnt_tile[nh:nyh-nh,nh:nxh-nh+1] = -999.0

    lon_halo_verts_crnt_tile = lon_verts_crnt_tile
    lon_halo_verts_crnt_tile[nh+1:nyh-nh,nh+1:nxh-nh] = -999.0
    lat_halo_verts_crnt_tile = lat_verts_crnt_tile
    lat_halo_verts_crnt_tile[nh+1:nyh-nh,nh+1:nxh-nh] = -999.0
#
# **********************************************************************
#
# If on a regional grid, if the current tile is tile 7 (the regional
# domain/grid), and if remove_rgnl_halo is set to True, then remove a
# halo of width nhalo_T7 cells from each of the coordinate arrays.
#
# **********************************************************************
#
    if (remove_halo):

      print("")
      print("  Removing halo cells from coordinate arrays of tile {n_tile}...")

#
# **********************************************************************
#
# Remove halo cells from the arrays containing coordinates of the cell
# vertices of the supergrid.
#
# **********************************************************************
#
      lon_verts_SG_crnt_tile = (
         lon_verts_SG_crnt_tile[nhSG:nyhSG-nhSG+1, nhSG:nxhSG-nhSG+1])
      lat_verts_SG_crnt_tile = (
         lat_verts_SG_crnt_tile[nhSG:nyhSG-nhSG+1, nhSG:nxhSG-nhSG+1])

#
# **********************************************************************
#
# Remove halo cells from the arrays containing the coordinates of cell
# centers of the computational grid.
#
# **********************************************************************
#
      lon_cntrs_crnt_tile = (
         lon_cntrs_crnt_tile[nh:nyh-1-nh+1, nh:nxh-1-nh+1])
      lat_cntrs_crnt_tile = (
         lat_cntrs_crnt_tile[nh:nyh-1-nh+1, nh:nxh-1-nh+1])

#
# **********************************************************************
#
# Remove halo cells from the arrays containing coordinates of the cell
# vertices of the computational grid.
#
# **********************************************************************
#

      lon_verts_crnt_tile = lon_verts_crnt_tile[nh:nyh-nh+1, nh:nxh-nh+1]
      lat_verts_crnt_tile = lat_verts_crnt_tile[nh:nyh-nh+1, nh:nxh-nh+1]

      print(f"  Done removing halo cells from coordinate arrays of "
            f"tile {n_tile}.")


#
# **********************************************************************
#
# Create arrays in unstructured format that contain the coordinates of
# the center of each cell on the current tile.  Note that these are 1-D
# arrays, and their size (i.e. the number of elements they contain) is
# equal to the number of cells on the current tile's grid (i.e. nxh*nyh
# or nx*ny).  This unstructured format is useful for generating color-
# contour plots of fields on the grid that have one value per cell
# represented by a flat color in that cell.
#
# **********************************************************************
#

    lon_cntrs_crnt_tile_unstruc = np.asarray(lon_cntrs_crnt_tile).flatten()
    lat_cntrs_crnt_tile_unstruc = np.asarray(lat_cntrs_crnt_tile).flatten()

    lon_halo_cntrs_crnt_tile_unstruc = np.asarray(lon_halo_cntrs_crnt_tile).flatten()
    lat_halo_cntrs_crnt_tile_unstruc = np.asarray(lat_halo_cntrs_crnt_tile).flatten()

#
# **********************************************************************
#
# Create arrays in unstructured format that contain the coordinates of
# the vertices of each cell on the current tile.  Note that these are
# 2-D arrays whose first dimension size is the number of cells on the
# current tile's grid (i.e. nxh*nyh or nx*ny) and whose second dimension
# size is 4 (since each cell has 4 vertices).  This unstructured format
# is useful for generating color-contour plots of fields on the grid
# that have one value per cell represented by a flat color in that cell.
#
# **********************************************************************
#
# Get dimensions again because they depend on whether the halo is being
# removed or not (remove_rgnl_halo).

    dims = np.asarray(lon_cntrs_crnt_tile).shape
    endx = dims[1]
    endy = dims[0]

    lon_verts_crnt_tile_unstruc = np.asarray([
          np.asarray(lon_verts_crnt_tile[0:endy,0:endx]).flatten(),
          np.asarray(lon_verts_crnt_tile[0:endy,1:endx+1]).flatten(),
          np.asarray(lon_verts_crnt_tile[1:endy+1,1:endx+1]).flatten(),
          np.asarray(lon_verts_crnt_tile[1:endy+1,0:endx]).flatten()])
    lon_verts_crnt_tile_unstruc = np.transpose(lon_verts_crnt_tile_unstruc)

    lat_verts_crnt_tile_unstruc = np.asarray([
          np.asarray(lat_verts_crnt_tile[0:endy,0:endx]).flatten(),
          np.asarray(lat_verts_crnt_tile[0:endy,1:endx+1]).flatten(),
          np.asarray(lat_verts_crnt_tile[1:endy+1,1:endx+1]).flatten(),
          np.asarray(lat_verts_crnt_tile[1:endy+1,0:endx]).flatten()])
    lat_verts_crnt_tile_unstruc = np.transpose(lat_verts_crnt_tile_unstruc)


#; Do same for halo coordinates.
    lon_halo_verts_crnt_tile_unstruc = np.asarray([
       np.array(lon_halo_verts_crnt_tile[0:nyh,0:nxh]).flatten(),
       np.array(lon_halo_verts_crnt_tile[0:nyh,1:nxh+1]).flatten(),
       np.array(lon_halo_verts_crnt_tile[1:nyh+1,1:nxh+1]).flatten(),
       np.array(lon_halo_verts_crnt_tile[1:nyh+1,0:nxh]).flatten()])
    lon_halo_verts_crnt_tile_unstruc = np.transpose(lon_halo_verts_crnt_tile_unstruc)

    lat_halo_verts_crnt_tile_unstruc = np.asarray([
       np.array(lat_halo_verts_crnt_tile[0:nyh-1,0:nxh]).flatten(),
       np.array(lat_halo_verts_crnt_tile[0:nyh-1,1:nxh+1]).flatten(),
       np.array(lat_halo_verts_crnt_tile[1:nyh,1:nxh+1]).flatten(),
       np.array(lat_halo_verts_crnt_tile[1:nyh,0:nxh]).flatten()])

    lat_halo_verts_crnt_tile_unstruc = np.transpose(lat_halo_verts_crnt_tile_unstruc)

    for i in range(nxh):
      for j in range(nyh):
        if (i >= nh) and (i <= nxh-nh-1) and (j >= nh) and (j <= nyh-nh-1):
          indx = i + j*nxh
          lon_halo_verts_crnt_tile_unstruc[indx,:] = -999.0
          lat_halo_verts_crnt_tile_unstruc[indx,:] = -999.0

#
# **********************************************************************
#
# Append to the unstructured arrays that will contain the coordinates of
# the cell centers and cell vertices on all specified tiles.  We refer
# to these as the "all-tiles" arrays.
#
# **********************************************************************
#

    lon_cntrs_all_tiles_unstruc = np.append(lon_cntrs_all_tiles_unstruc,
          lon_cntrs_crnt_tile_unstruc)
    lat_cntrs_all_tiles_unstruc = np.append(lat_cntrs_crnt_tile_unstruc,
          lat_cntrs_crnt_tile_unstruc)

    lon_halo_cntrs_all_tiles_unstruc = np.append(lon_halo_cntrs_all_tiles_unstruc,
          lon_halo_cntrs_crnt_tile_unstruc)
    lat_halo_cntrs_all_tiles_unstruc = np.append(lat_halo_cntrs_crnt_tile_unstruc,
          lat_halo_cntrs_crnt_tile_unstruc)

    if(nn == 0):
       lon_verts_all_tiles_unstruc = lon_verts_crnt_tile_unstruc
       lat_verts_all_tiles_unstruc = lat_verts_crnt_tile_unstruc

       lon_halo_verts_all_tiles_unstruc = lon_halo_verts_crnt_tile_unstruc
       lat_halo_verts_all_tiles_unstruc = lat_halo_verts_crnt_tile_unstruc
    else:
       lon_verts_all_tiles_unstruc = np.vstack((lon_verts_all_tiles_unstruc,
          lon_verts_crnt_tile_unstruc))
       lat_verts_all_tiles_unstruc = np.vstack((lat_verts_all_tiles_unstruc,
          lat_verts_crnt_tile_unstruc))

       lon_halo_verts_all_tiles_unstruc = np.vstack((lon_halo_verts_all_tiles_unstruc,
          lon_halo_verts_crnt_tile_unstruc))
       lat_halo_verts_all_tiles_unstruc = np.vstack((lat_halo_verts_all_tiles_unstruc,
          lat_halo_verts_crnt_tile_unstruc))

#
# **********************************************************************
#
# If get_tile_bdies is True, generate unstructured boundary coordinate
# arrays.
#
# **********************************************************************
#
    if (get_tile_bdies):
#
# First, get the coordinates of the boundary points on the current tile.
# Here, by "boundary points", we mean those cell vertices that happen to
# lie on the tile's boundary.
#
      repeat_last_point = True
      array_order = "ji"
      bdy_info = get_rect_grid_bdy(
                  lon_verts_crnt_tile, lat_verts_crnt_tile,
                  repeat_last_point, array_order)
      lon_bdy_crnt_tile = bdy_info["x_bdy"]
      lat_bdy_crnt_tile = bdy_info["y_bdy"]

#
# Append to the arrays that will contain the coordinates of the boundary
# points on all specified tiles.  We refer to these as the "all-tiles"
# arrays.
#

      lon_bdy_all_tiles = np.append(lon_bdy_all_tiles, lon_bdy_crnt_tile)
      lat_bdy_all_tiles = np.append(lat_bdy_all_tiles, lat_bdy_crnt_tile)


# Do same for halo coordinates.
#
# First, get the coordinates of the boundary points on the current tile.
# Here, by "boundary points", we mean those cell vertices that happen to
# lie on the tile's boundary.
#
      repeat_last_point = True
      array_order = "ji"
      bdy_info = get_rect_grid_bdy(
                  lon_halo_verts_crnt_tile, lat_halo_verts_crnt_tile,
                  repeat_last_point, array_order)
      lon_halo_bdy_crnt_tile = bdy_info["x_bdy"]
      lat_halo_bdy_crnt_tile = bdy_info["y_bdy"]

#
# Append to the arrays that will contain the coordinates of the boundary
# points on all specified tiles.  We refer to these as the "all-tiles"
# arrays.
#
      lon_halo_bdy_all_tiles = np.append(
         lon_halo_bdy_all_tiles, lon_halo_bdy_crnt_tile)
      lat_halo_bdy_all_tiles = np.append(
         lat_halo_bdy_all_tiles, lat_halo_bdy_crnt_tile)

#
# **********************************************************************
#
# Find and print out the coordinates of the corners of the current tile.
#
# **********************************************************************
#

    x_is_longitude = True
    opts = {"verbose" : False}
    corner_info = get_rect_grid_corners(
                   lon_verts_crnt_tile, lat_verts_crnt_tile,
                   "deg", "deg", x_is_longitude, opts)
    corner_lons = corner_info["x_corners"]
    corner_lats = corner_info["y_corners"]

    print("")
    print("  Tile corner lon/lat coordinates are:")
    fmt_str = "%7.2f"
    for c in range(len(corner_lons)):
      lon_str = f"{corner_lons[c]:7.2f}"
      lat_str = f"{corner_lats[c]:7.2f}"
      print(f"    Corner {c+1}:  lon = {lon_str} deg;  lat = {lat_str} deg")
#
# **********************************************************************
#
# Set the i-indices of the domain's left (west) boundary, center, and
# right (east) boundary and the j-indices of the bottom (south) boundary,
# middle (center), and top (north) boundary in the arrays containing the
# coordinates of the supergrid.
#
# **********************************************************************
#
    if (remove_halo):

      i_left = 0
      i_cntr = int(nxSG/2)
      i_rght = nxSG

      j_bot = 0
      j_mid = int(nySG/2)
      j_top = nySG

    else:

      i_left = 0
      i_cntr = int(nxhSG/2)
      i_rght = nxhSG

      j_bot = 0
      j_mid = int(nyhSG/2)
      j_top = nyhSG

#
# **********************************************************************
#
# Check whether any of the four faces of the current tile cross the
# international date line (IDL).  This is important because if so, we
# will not be able to identify the southwest (SW), southeast (SE),
# northwest (NW), and northeast (NE) corners of the tile.  We perform
# this check for each face by checking whether there is a jump in the
# longitudes of grid cell corner points that lie on the face as we move
# along the face.
#
# Note that if one (or both) of the poles lies within the tile, then one
# of the tile faces must cross the IDL.  Thus, the IDL crossing check
# below will be triggered if one or both poles lie within the tile, but
# the triggering of this check does not necessarily imply that one or
# both poles lie within the tile (i.e. crossing of the IDL by a tile
# boundary is a necessary but not sufficient condition for one or both
# poles to lie within the tile).  Below, if the IDL crossing check is
# triggered, we do not go further to check whether or not one or both
# poles lie within the tile (because that test is more complex).
#
# **********************************************************************
#

    face_id_strs = ["bottom", "right", "top", "left"]
    num_faces = len(face_id_strs)
    if (False):
      #abs_dlon_cutoff = 0.0d+0  ; For debugging only.
      abs_dlon_cutoff = 180.0

      abs_dlon_cutoff_str = f"{abs_dlon_cutoff:8.4f}"

      face_id_strs = ["bottom", "right", "top", "left"]
      num_faces = np.shape(face_id_strs)
      for i in range(num_faces):

        face_id_str = face_id_strs[i]
        if (face_id_str == "bottom"):
          lon_crnt_face = lon_verts_SG_crnt_tile[j_bot,:]
        elif (face_id_str == "right"):
          lon_crnt_face = lon_verts_SG_crnt_tile[:,i_rght]
        elif (face_id_str == "top"):
          lon_crnt_face = lon_verts_SG_crnt_tile[j_top,:]
        elif  (face_id_str == "left"):
          lon_crnt_face = lon_verts_SG_crnt_tile[:,i_left]

        num_face_pts = dimsizes(lon_crnt_face)
        dlon = lon_crnt_face[1:num_face_pts] - lon_crnt_face[0:num_face_pts-1]
        abs_dlon_max = max(abs(dlon))

        if (abs_dlon_max >= abs_dlon_cutoff):
          abs_dlon_max_str = f"{abs_dlon_max:8.4f}"
          lat_str = f"{abs_dlat_max:8.4f}"
          print("")
          print(f'The "{face_id_str}" boundary of the current tile '
            f"crosses the international date")
          print(f"line (IDL) because there is a jump in longitude (abs_dlon_max) from one")
          print(f"grid point to the next along that boundary with a magnitude that is greater")
          print(f'than or equal to the maximum allowed value specified by "{abs_dlon_cutoff}":')
          print(f"  abs_dlon_max    = {abs_dlon_max_str} deg")
          print(f"  abs_dlon_cutoff = {abs_dlon_cutoff_str} deg")
          print(f"Please express the longitude and latitude of the grid points in a rotated")
          print(f"lat/lon coordinate system to avoid this problem.")
          print(f"Stopping.")
          raise ValueError()

#
# **********************************************************************
#
# Save in lon_tile_corners_crnt_tile and lat_tile_corners_crnt_tile the
# longitudes and latitudes of the four corners of the current tile,
# starting with the lower left corner and proceeding counterclockwise to
# the upper right corner.
#
# **********************************************************************
#

    num_corners = 4
    lon_tile_corners_crnt_tile = np.zeros(4)
    lat_tile_corners_crnt_tile = np.zeros(4)

    i = 0
    lon_tile_corners_crnt_tile[i] = lon_verts_SG_crnt_tile[j_bot, i_left]
    lat_tile_corners_crnt_tile[i] = lat_verts_SG_crnt_tile[j_bot, i_left]

    i = i + 1
    lon_tile_corners_crnt_tile[i] = lon_verts_SG_crnt_tile[j_bot, i_rght]
    lat_tile_corners_crnt_tile[i] = lat_verts_SG_crnt_tile[j_bot, i_rght]

    i = i + 1
    lon_tile_corners_crnt_tile[i] = lon_verts_SG_crnt_tile[j_top, i_rght]
    lat_tile_corners_crnt_tile[i] = lat_verts_SG_crnt_tile[j_top, i_rght]

    i = i + 1
    lon_tile_corners_crnt_tile[i] = lon_verts_SG_crnt_tile[j_top, i_left]
    lat_tile_corners_crnt_tile[i] = lat_verts_SG_crnt_tile[j_top, i_left]

#
# **********************************************************************
#
# Save in lon_face_midpts_crnt_tile and lat_face_midpts_crnt_tile the
# longitudes and latitudes of the midpoints of the four faces of the
# current tile, starting with the bottom face and proceeding counterclockwise
# to the left face.
#
# **********************************************************************
#
#    num_faces = 4

    lon_face_midpts_crnt_tile = np.zeros(num_faces)
    lat_face_midpts_crnt_tile = np.zeros(num_faces)

    i = 0
    lon_face_midpts_crnt_tile[i] = lon_verts_SG_crnt_tile[j_bot, i_cntr]
    lat_face_midpts_crnt_tile[i] = lat_verts_SG_crnt_tile[j_bot, i_cntr]

    i = i + 1
    lon_face_midpts_crnt_tile[i] = lon_verts_SG_crnt_tile[j_mid, i_rght]
    lat_face_midpts_crnt_tile[i] = lat_verts_SG_crnt_tile[j_mid, i_rght]

    i = i + 1
    lon_face_midpts_crnt_tile[i] = lon_verts_SG_crnt_tile[j_top, i_cntr]
    lat_face_midpts_crnt_tile[i] = lat_verts_SG_crnt_tile[j_top, i_cntr]

    i = i + 1
    lon_face_midpts_crnt_tile[i] = lon_verts_SG_crnt_tile[j_mid, i_left]
    lat_face_midpts_crnt_tile[i] = lat_verts_SG_crnt_tile[j_mid, i_left]

#
# **********************************************************************
#
# Now find the indices into lon_tile_corners_crnt_tile (or
# lat_tile_corners_crnt_tile) of the southwest, southeast, northeast,
# and northwest corners of the current tile.
#
# **********************************************************************
#

    indx_SW = np.zeros(1)
    indx_SE = np.zeros(1)
    indx_NE = np.zeros(1)
    indx_NW = np.zeros(1)

    for i in range(num_corners):

      ip1 = i + 1
      if (ip1 > num_corners-1):
        ip1 = 0

      ip2 = ip1 + 1
      if (ip2 > num_corners-1):
        ip2 = 0

      ip3 = ip2 + 1
      if (ip3 > num_corners-1):
        ip3 = 0

      lon_i = lon_tile_corners_crnt_tile[i]
      lat_i = lat_tile_corners_crnt_tile[i]

      lon_ip1 = lon_tile_corners_crnt_tile[ip1]
      lat_ip1 = lat_tile_corners_crnt_tile[ip1]

      lon_ip2 = lon_tile_corners_crnt_tile[ip2]
      lat_ip2 = lat_tile_corners_crnt_tile[ip2]

      lon_ip3 = lon_tile_corners_crnt_tile[ip3]
      lat_ip3 = lat_tile_corners_crnt_tile[ip3]

      if ((indx_SW) is None and
          (lon_i < lon_ip1) and
          (lon_i < lon_ip2) and
          (lat_i < lat_ip2) and
          (lat_i < lat_ip3)):
         indx_SW = i

      if (indx_SE is None and
          (lon_i > lon_ip2) and
          (lon_i > lon_ip3) and
          (lat_i < lat_ip1) and
          (lat_i < lat_ip2)):
         indx_SE = i

      if (indx_NE is None and
          (lon_i > lon_ip1) and
          (lon_i > lon_ip2) and
          (lat_i > lat_ip2) and
          (lat_i > lat_ip3)):
         indx_NE = i

      if (indx_NW is None and
          (lon_i < lon_ip2) and
          (lon_i < lon_ip3) and
          (lat_i > lat_ip1) and
          (lat_i > lat_ip2)):
         indx_NW = i

      indx_SW = [0]
      indx_SE = [1]
      indx_NE = [2]
      indx_NW = [3]

#
# **********************************************************************
#
# Now rearrange the lon_tile_corners_crnt_tile and lat_tile_corners_crnt_tile
# arrays so that the first element corresponds to the southwest corner of
# the tile, the second corresponds to the southeast corner, the third
# corresponds to the northeast corner, and the fourth corresponds to the
# northwest corner.  Also, rearange the lon_face_midpts_crnt_tile and
# lat_face_midpts_crnt_tile arrays so that the first element corresponds
# to the southern face, the second corresponds to the eastern face, the
# third corresponds to the northern face, and the fourth corresponds to
# the western face.
#
# **********************************************************************
#
# IMPORTANT NOTE:
# For a global cubed-sphere grid, for three of the tiles (the ones over
# the north and south poles and the one that straddles the IDL), the
# indices of the SW, SE, NE, and NW corners of the tile will not be set
# (they will remain set to their initial missing values), so the check
# below will be triggered.  Something more complex needs to be done for
# such tiles, but we do not worry about it here for now since we're only
# dealing with regional domains.
#

    inds_reorder = [indx_SW, indx_SE, indx_NE, indx_NW]
    if None in inds_reorder:
      print()
      print(f"One or more of the indices for the SW, SE, NE, and NW corners of the")
      print(f"current tile have not been set:")
      print(f"  indx_SW = {indx_SW}")
      print(f"  indx_SE = {indx_SE}")
      print(f"  indx_NE = {indx_NE}")
      print(f"  indx_NW = {indx_NW}")
      print("Stopping")
      raise ValueError(msg)

    lon_tile_corners_crnt_tile = lon_tile_corners_crnt_tile[inds_reorder][:,0]
    lat_tile_corners_crnt_tile = lat_tile_corners_crnt_tile[inds_reorder][:,0]

    lon_face_midpts_crnt_tile = lon_face_midpts_crnt_tile[inds_reorder][:,0]
    lat_face_midpts_crnt_tile = lat_face_midpts_crnt_tile[inds_reorder][:,0]

#
# **********************************************************************
#
# Now save the reordered tile corner and tile face midpoint coordinate
# arrays for the current tile in the arrays containing the coordinates
# for all tiles.
#
# **********************************************************************
#

    inds = [0, 2, 4, 6]
    inds1 = [1, 3, 5, 7]

    lon_tile_corners_face_midpts_all_tiles[nn,inds] = lon_tile_corners_crnt_tile
    lon_tile_corners_face_midpts_all_tiles[nn,inds1] = lon_face_midpts_crnt_tile

    lat_tile_corners_face_midpts_all_tiles[nn,inds] = lat_tile_corners_crnt_tile
    lat_tile_corners_face_midpts_all_tiles[nn,inds1] = lat_face_midpts_crnt_tile

#
# **********************************************************************
#
# Calculate the coordinates of the center of the current tile as well as
# the coordinates of the tile corners and the midpoints of the four tile
# faces.
#
# **********************************************************************
#
    lon_tile_cntr_all_tiles = np.append(lon_tile_cntr_all_tiles,
          lon_verts_SG_crnt_tile[j_mid, i_cntr])
    lat_tile_cntr_all_tiles = np.append( lat_tile_cntr_all_tiles,
          lat_verts_SG_crnt_tile[j_mid, i_cntr])
#
# **********************************************************************
#
# Print out the coordinates of tile corners and tile face midpoints.
#
# **********************************************************************
#
    lon_str = [f"{val:10.6f} deg" for val in
          lon_tile_corners_face_midpts_all_tiles[nn,:]]
    lat_str = [f"{val:10.6f} deg" for val in
          lat_tile_corners_face_midpts_all_tiles[nn,:]]

    loc_names = [ "SW_corner:    ", "S_face_midpt: ",
          "SE_corner:    ", "E_face_midpt: ",
          "NE_corner:    ", "N_face_midpt: ",
          "NW_corner:    ", "W_face_midpt: " ]

    print(f"Longitudes and latitudes of the corners and face midpoints of tile #{n_tile}")
    for i in range(len(lon_str)):
       print(f"    {loc_names[i]}  lon = {lon_str[i]};  lat = {lat_str[i]}")

  print("")
  print("Done reading in grid coordinates of each specified tile.")
  print(separator_line)

#
# **********************************************************************
#
# Remove the first elements in the unstructured arrays containing the
# coordinates of the grid cells and tile boundaries.  Recall that these
# first elements were defined to make it convenient to append the coordinates
# of each consecutive tile; they contain missing values of type coord_data_type.
#
# **********************************************************************
#

  if (get_tile_bdies):
    lon_bdy_all_tiles = lon_bdy_all_tiles[:]
    lat_bdy_all_tiles = lat_bdy_all_tiles[:]
    lon_halo_bdy_all_tiles = lon_halo_bdy_all_tiles[:]
    lat_halo_bdy_all_tiles = lat_halo_bdy_all_tiles[:]

#
# **********************************************************************
#
# Return results as attributes of the logical variable grid_info.
#
# **********************************************************************
#

  grid_info = {"fp" : fp,
     "grid_fn_all_tiles" : grid_fn_all_tiles,
     "nhSG_all_tiles" : nhSG_all_tiles,
     "nxhSG_all_tiles" : nxhSG_all_tiles,
     "nyhSG_all_tiles" : nyhSG_all_tiles,
     "nxSG_all_tiles" : nxSG_all_tiles,
     "nySG_all_tiles" : nySG_all_tiles,
     "nh_all_tiles" : nh_all_tiles,
     "nxh_all_tiles" : nxh_all_tiles,
     "nyh_all_tiles" : nyh_all_tiles,
     "nx_all_tiles" : nx_all_tiles,
     "ny_all_tiles" : ny_all_tiles,
     "remove_halo_all_tiles" : remove_halo_all_tiles,
     "lon_cntrs_all_tiles_unstruc" : lon_cntrs_all_tiles_unstruc,
     "lat_cntrs_all_tiles_unstruc" : lat_cntrs_all_tiles_unstruc,
     "lon_verts_all_tiles_unstruc" : lon_verts_all_tiles_unstruc,
     "lat_verts_all_tiles_unstruc" : lat_verts_all_tiles_unstruc,
     "lon_bdy_all_tiles" : lon_bdy_all_tiles,
     "lat_bdy_all_tiles" : lat_bdy_all_tiles,
     "lon_halo_cntrs_all_tiles_unstruc" : lon_halo_cntrs_all_tiles_unstruc,
     "lat_halo_cntrs_all_tiles_unstruc" : lat_halo_cntrs_all_tiles_unstruc,
     "lon_halo_verts_all_tiles_unstruc" : lon_halo_verts_all_tiles_unstruc,
     "lat_halo_verts_all_tiles_unstruc" : lat_halo_verts_all_tiles_unstruc,
     "lon_halo_bdy_all_tiles" : lon_halo_bdy_all_tiles,
     "lat_halo_bdy_all_tiles" : lat_halo_bdy_all_tiles,
     "lon_tile_cntr_all_tiles" : lon_tile_cntr_all_tiles,
     "lat_tile_cntr_all_tiles" : lat_tile_cntr_all_tiles,
     "lon_tile_corners_face_midpts_all_tiles" :
         lon_tile_corners_face_midpts_all_tiles,
     "lat_tile_corners_face_midpts_all_tiles" :
         lat_tile_corners_face_midpts_all_tiles}

  return(grid_info)
